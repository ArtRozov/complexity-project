## Полиномиальный алгоритм приближённого решения

### Описание алгоритма

1. **Использование алгоритма Краскала:**
   - Начнем с построения остовного дерева с использованием алгоритма Краскала.

2. **Фазы алгоритма (метод `PhasesInit`):**
   - Алгоритм работает в несколько фаз.
   - Пусть $k$ - максимальная степень вершины в текущем остовном дереве.
   - На каждой фазе алгоритм стремится уменьшить количество вершин степени $k$. Для этого рассматриваются множества $S_k$ и $S_{k-1}$ вершин степени $k$ и $k-1$ соответственно.
   - На начало фазы (метод `ComponentsDivision`), все вершины, кроме $S_k \cup S_{k-1}$ помечаются как хорошие (в коде `mark[vert] = true`), т.к. степень данных вершин можно увеличивать, а вершины степени хотя бы $k-1$ - как плохие (`mark[vert] = false`), т.к. степень данных мы обязаны уменьшить.
   - Затем рассматривается лес $F$ деревьев, образованных удалением вершин $S_k \cup S_{k-1}$ (в коде лес хранится неявно с помощью `DSU`).
   - Ищутся рёбра в исходном графе $G$, соединяющие две *хорошие* вершины из разных деревьев леса $F$.
   - Если такого ребра нет, то алгоритм завершается и возвращает найденный ответ.
   - При нахождении ребра, алгоритм ищет цикл, который образовался в остовном дереве при добавлении этого ребра(метод `FindPathDFS`).
   - Если находится вершина степени $k$, то происходит *распространение* улучшения (метод `Improve`), т.е. уменьшение степени за счёт *хороших* вершин.
   - Если не находится вершина степени $k$, то находится хотя бы одна вершина степени $k-1$, и степень этой вершины в нашем остовном дереве может быть уменьшена, т.е. добавить в остовное дерево $T$ ребро $(u,v)$ и убрать одно ребро из цикла с концом в $w$, не совпадающих с $(u,v)$. $u,v \textsf{ - 2 хорошие вершины, а } w \textsf{ - внутренняя вершина пути от u до v в исходном остовном дереве}$

3. **Асимптотика алгоритма:**

   1. **Построение остовного дерева методом Краскала:**
      - Временная сложность поиска остовного дерева с использованием алгоритма Краскала равна $O(m \log n)$, где $m$ - количество рёбер, $n$ - количество вершин.

   2. **Фазы алгоритма:**
      - Количество фаз может быть ограничено сверху $n$, так как на каждой фазе уменьшается количество вершин степени $k$.
      - Каждая фаза включает поиск рёбер между "хорошими" вершинами в лесу, который содержит не более $n$ вершин. Поиск таких рёбер занимает $O(n^2)$ в худшем случае.
      - Таким образом, общее время для всех фаз может быть оценено как $O(n^3)$.

   3. **Поиск цикла и улучшение:**
      - Поиск цикла осуществляется обходом в глубину, что занимает $O(n)$.
      - Попытка улучшения также занимает $O(n)$.
      - Поскольку таких улучшений выполняется не более $n$ раз на каждой фазе, общее время на этапе улучшения можно оценить как $O(n^4)$.

   Итак, общая асимптотика алгоритма будет $O(m \log n + n^3 + n^4)$, где $m$ - количество рёбер, $n$ - количество вершин.